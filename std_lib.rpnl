; floor
$0 1 \ floor|1

; abs
$0 $0 -1 * $0 0 ~ ? abs|1

; iterative fibonacci
$1 $0 $1 + $2 1 ~ $1 $2 fib_aux@3
1 0 $0 fib_aux fib|1

; modulo
$0 1 $1 _ mod|2

; phi approximation using fibonacci numbers
; the argument specifies the number of iterations
$1 $0 $1 + $2 1 ~ $1 $0 / $2 phi_aux@3
1 1 $0 phi_aux phi|1

; factorial
$0 $1 * $1 1 ~ $0 $1 fact_aux@2
1 $0 fact_aux fact|1

; binomial coefficient
$0 $1 $2 / * $1 1 - $2 1 ~ $0 $2 bin_aux@3
1 $0 $1 bin_aux bin|2

; gsum
; sum of the first $0 integers using Gauss' formula
$0 $0 1 + * 2 / gsum|1

; sift
; sum of the integer from $0 to $1, both included
; (generalization of gauss' sum)
$1 gsum $0 1 - gsum - sift|2

; Ackermann function
; this is very slow and memory demanding
; for high enough values it will cause a stack overflow
    $0 1 ~ 
$0 $1 1 ~ ack
1
    $1 ?
    $1 1 +
        $0 ack@2

; "Hello, World!"
2645608968345021733469237830984 =hello

; '\n'
10 =lf

; '\r'
13 =cr

; characters 'a', 'A' and '0'
97 =chara
65 =charA
48 =char0

; empty string
0 =null

; cons
; put the character $0 in front of the string $1
$1 256 * $0 + cons|2

; cat
; concatenates string $0 with string $1
; can be improved with a more efficient find_end
$0 $1 256 * $1 $0 $1 ~ find_end@2
$1 $0 1 find_end * $0 + cat|2

; WIP for faster find_end
;$0 $1 $1 * $2 2 * $2 $0 $1 ~ overshoot@3
;find_between@3
;$1 $0 $0 2 \ find_between find_end_aux|2
;$0 256 1 overshoot $0 find_end|1

; reverse
; reverses a string
$0 256 \ $0 256 mod $1 cons $1 $0 reverse_aux@2
$0 0 reverse_aux reverse|1

; to_string
; doesn't work with non positive integers (non naturals)
$0 10 \ $0 10 mod char0 + $1 cons $1 $0 to_string_aux@2
$0 0 to_string_aux to_string|1



; //////////

; deprecated (replaced by '^')
; power/exponentiation
$0 $0 *
$1 2 \
$2 $0 * $2 $1 2 mod ?
    $2
    $1
    exp_aux@3
$0 $1 floor abs 1 exp_aux exp|2

; deprecated (replaced by '_')
; exponentiation modulo (fast exponentiation algorithm, temporarily not working)
$0 $0 *
$1 2 \
$2 $0 * $3 mod $2 $1 2 mod ?
$3
    $2
    $1
    mod_exp_aux@4
$0 $1 floor abs 1 $2 mod_exp_aux mod_exp|3
